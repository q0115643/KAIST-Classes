#lang plai

;area-square: number -> number
;to compute the area of a square with length of both sides
;(area-square 10) should produce 100
(define (area-square a)
  (* a a ))
(test (area-square 4) 16)
(test (area-square 10) 100)

;volume-cuboid: number number number -> number
;to compute the volume of a cuboid with lengths of all three sides
;(volume-cuboid 3 8 5) should produce 120
(define (volume-cuboid a b c)
  (* a b c))
(test (volume-cuboid 2 3 4) 24)
(test (volume-cuboid 3 8 5) 120)

;is-multiple-of?: number number -> boolean
;to check if the first number is a multiple of the second number
;(is-multiple-of? 81 27) should say true
(define (is-multiple-of? a b)
  (= (remainder a b) 0))
(test (is-multiple-of? 3 1) true)
(test (is-multiple-of? 7 2) false)
(test (is-multiple-of? 17 7) false)
(test (is-multiple-of? 7 18) false)
(test (is-multiple-of? 81 27) true)

;factorial: number -> number
;to compute the factorial operation of a number
;(factorial 6) should produce 720
(define (factorial a)
  (cond
    [(= a 0) 1]
    [else (* a (factorial(- a 1)))]))
(test (factorial 3) 6)
(test (factorial 0) 1)
(test (factorial 6) 720)

;fibonacci: number -> number
;to compute n-th fibonacci number with a number n
;(fibonacci 11) should produce 89
(define (fibonacci n)
  (cond
    [(= n 1) 1]
    [(= n 2) 1]
    [else (+ (fibonacci(- n 1)) (fibonacci(- n 2)))]))
(test (fibonacci 2) 1)
(test (fibonacci 3) 2)
(test (fibonacci 6) 8)
(test (fibonacci 11) 89)

;(CS320? (CS320 '(4 12))) should say true
(define-type COURSE
  [CS320 (quiz integer?) (homework integer?)]
  [CS311 (homework integer?)]
  [CS330 (projects integer?) (homework integer?)])
(test(CS320? (CS320 4 12)) #t)

;total-assignments: COURSE -> number
;to consume a course and produce the total number of quizzes, homework, and projects for the given course
;(total-assignments cs330) should produce 18
(define cs320 (CS320 4 12))
(define cs311 (CS311 15))
(define cs330 (CS330 8 10))
(define (total-assignments cs)
  (type-case COURSE cs
    [CS320 (a b) (+ a b)]
    [CS311 (a) a]
    [CS330 (a b) (+ a b)]))
(test (total-assignments cs320) 16)
(test (total-assignments cs311) 15)
(test (total-assignments cs330) 18)

;total-homework: list -> number
;to consume a list of courses and produce the total number of homework of the courses in the given list
;(total-homework (list cs320 cs311 cs330)) should produce 37
(define courses (list cs320 cs311 cs330))
(test (CS320-homework (first courses)) 12)
(test (CS311-homework (first (rest courses))) 15)
(test (CS330-homework (first (rest (rest courses)))) 10)
(define (total-homework cslist)
  (cond
  [(empty? cslist) 0]
  [(CS320? (first cslist)) (+ (CS320-homework (first cslist)) (total-homework (rest cslist)))]
  [(CS311? (first cslist)) (+ (CS311-homework (first cslist)) (total-homework (rest cslist)))]
  [(CS330? (first cslist)) (+ (CS330-homework (first cslist)) (total-homework (rest cslist)))]))
(test (total-homework (rest courses)) 25)
(test (total-homework courses) 37)
(test (total-homework (rest (rest courses))) 10)
(test (total-homework (list cs320 cs311 cs330)) 37)

;my-map: function list -> list
;to consume a function f and a list of numbers l, and produce a list of numbers generated by applying the input funciton f to each element of l
;(my-map (lambda (x) (+ 3 x)) (list 10 13 15 20 30)) should produce '(13 16 18 23 33)
(define (testf a)
  (* a a))
(define testl (list 1 2 3 4 5 6 7 8 9 10))
(define (my-map f l)
  (cond
    [(empty? l) empty]
    [else (cons (f (first l)) (my-map f (rest l)))]))
(test (my-map testf testl) '(1 4 9 16 25 36 49 64 81 100))
(test (my-map (lambda (x) (+ 3 x)) (list 10 13 15 20 30)) '(13 16 18 23 33))

;my-filter: function list -> list
;to consume a predicate function f and a list of numbers l, and produce a list consisting of the elements of l that satisfy the predicate f
;(my-filter (lambda (x) (> x 100)) (list 111 99 33 1234 49 33 1119)) should produce '(111 1234 1119)
(define (testf2 a)
  (> a 5))
(define testl2 (list 2 4 8 3 23 0 -3 123 7 384))
(define (my-filter f l)
  (cond
    [(empty? l) empty]
    [(f (first l)) (cons (first l) (my-filter f (rest l)))]
    [else (my-filter f (rest l))]))
(test (my-filter testf2 testl2) '(8 23 123 7 384))
(test (my-filter (lambda (x) (> x 100)) (list 111 99 33 1234 49 33 1119)) '(111 1234 1119))